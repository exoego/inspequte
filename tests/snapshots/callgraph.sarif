{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json",
  "runs": [
    {
      "artifacts": [
        {
          "length": 270,
          "location": {
            "uri": "A.class"
          },
          "roles": [
            "analysisTarget"
          ]
        },
        {
          "length": 192,
          "location": {
            "uri": "B.class"
          },
          "roles": [
            "analysisTarget"
          ]
        }
      ],
      "invocations": [
        {
          "arguments": [],
          "executionSuccessful": true
        }
      ],
      "results": [],
      "tool": {
        "driver": {
          "informationUri": "https://github.com/KengoTODA/inspequte",
          "name": "inspequte",
          "rules": [
            {
              "id": "ARRAY_EQUALS",
              "name": "Array equals",
              "shortDescription": {
                "text": "Array comparisons using == or equals()"
              }
            },
            {
              "id": "BIGDECIMAL_DIVIDE_WITHOUT_ROUNDING",
              "name": "BigDecimal divide without rounding",
              "shortDescription": {
                "text": "BigDecimal.divide(BigDecimal) can throw on non-terminating decimals"
              }
            },
            {
              "id": "BIGDECIMAL_EQUALS_CALL",
              "name": "BigDecimal equals call",
              "shortDescription": {
                "text": "BigDecimal.equals compares value and scale instead of numeric equality"
              }
            },
            {
              "id": "BIGDECIMAL_FROM_DOUBLE",
              "name": "BigDecimal from double",
              "shortDescription": {
                "text": "BigDecimal constructors with double can introduce precision surprises"
              }
            },
            {
              "id": "BIGDECIMAL_SET_SCALE_WITHOUT_ROUNDING",
              "name": "BigDecimal setScale without rounding",
              "shortDescription": {
                "text": "BigDecimal.setScale(int) can throw when rounding is required"
              }
            },
            {
              "id": "DELETE_ON_EXIT_CALL",
              "name": "File.deleteOnExit call",
              "shortDescription": {
                "text": "File.deleteOnExit can accumulate pending deletions in long-lived processes"
              }
            },
            {
              "id": "DESERIALIZATION_READ_OBJECT_CALL",
              "name": "ObjectInputStream deserialization call",
              "shortDescription": {
                "text": "readObject/readUnshared are high-risk Java deserialization entry points"
              }
            },
            {
              "id": "EMPTY_CATCH",
              "name": "Empty catch block",
              "shortDescription": {
                "text": "Catch blocks with no meaningful instructions"
              }
            },
            {
              "id": "EXCEPTION_CAUSE_NOT_PRESERVED",
              "name": "Exception cause not preserved",
              "shortDescription": {
                "text": "Catch handlers that throw new exceptions without preserving the cause"
              }
            },
            {
              "id": "EXPLICIT_GC_CALL",
              "name": "Explicit GC call",
              "shortDescription": {
                "text": "Direct calls to explicit GC APIs should be avoided"
              }
            },
            {
              "id": "FUTURE_GET_WITHOUT_TIMEOUT",
              "name": "Future.get without timeout",
              "shortDescription": {
                "text": "Timeout-free Future.get calls can block indefinitely"
              }
            },
            {
              "id": "INEFFECTIVE_EQUALS_HASHCODE",
              "name": "Ineffective equals/hashCode",
              "shortDescription": {
                "text": "Classes with equals without hashCode or vice versa"
              }
            },
            {
              "id": "INSECURE_API",
              "name": "Insecure API usage",
              "shortDescription": {
                "text": "Calls to insecure process or reflection APIs"
              }
            },
            {
              "id": "INTEGER_GETINTEGER_CALL",
              "name": "Integer.getInteger call",
              "shortDescription": {
                "text": "Integer.getInteger reads system properties, not numeric input strings"
              }
            },
            {
              "id": "INTERRUPTED_EXCEPTION_NOT_RESTORED",
              "name": "InterruptedException not properly handled",
              "shortDescription": {
                "text": "Restore interrupt status when catching InterruptedException"
              }
            },
            {
              "id": "LOCK_NOT_RELEASED_ON_EXCEPTION_PATH",
              "name": "Lock acquired without guaranteed release",
              "shortDescription": {
                "text": "Lock.lock() must be followed by unlock() on every reachable exit path"
              }
            },
            {
              "id": "LOG4J2_FORMAT_SHOULD_BE_CONST",
              "name": "Log4j2 format should be const",
              "shortDescription": {
                "text": "Log4j2 format strings should be compile-time constants"
              }
            },
            {
              "id": "LOG4J2_ILLEGAL_PASSED_CLASS",
              "name": "Log4j2 illegal passed class",
              "shortDescription": {
                "text": "LogManager.getLogger should be called with the caller class"
              }
            },
            {
              "id": "LOG4J2_LOGGER_SHOULD_BE_FINAL",
              "name": "Log4j2 logger should be final",
              "shortDescription": {
                "text": "Log4j2 Logger fields should be final"
              }
            },
            {
              "id": "LOG4J2_LOGGER_SHOULD_BE_PRIVATE",
              "name": "Log4j2 logger should be private",
              "shortDescription": {
                "text": "Log4j2 Logger fields should be private"
              }
            },
            {
              "id": "LOG4J2_MANUALLY_PROVIDED_MESSAGE",
              "name": "Log4j2 preformatted message",
              "shortDescription": {
                "text": "Log4j2 messages should use placeholders instead of manual formatting"
              }
            },
            {
              "id": "LOG4J2_SIGN_ONLY_FORMAT",
              "name": "Log4j2 placeholder-only format",
              "shortDescription": {
                "text": "Log4j2 format strings should include descriptive text"
              }
            },
            {
              "id": "LOG4J2_UNKNOWN_ARRAY",
              "name": "Log4j2 unknown array",
              "shortDescription": {
                "text": "Log4j2 varargs calls with unknown argument arrays"
              }
            },
            {
              "id": "LONG_GETLONG_CALL",
              "name": "Long.getLong call",
              "shortDescription": {
                "text": "Long.getLong reads system properties, not numeric input strings"
              }
            },
            {
              "id": "MUTATE_UNMODIFIABLE_COLLECTION",
              "name": "Mutation on unmodifiable collection",
              "shortDescription": {
                "text": "Mutation calls on known JDK unmodifiable collection values"
              }
            },
            {
              "id": "NULLNESS",
              "name": "Nullness checks",
              "shortDescription": {
                "text": "Nullness issues guided by JSpecify annotations"
              }
            },
            {
              "id": "OBJECT_WAIT_WITHOUT_TIMEOUT",
              "name": "Object.wait without timeout",
              "shortDescription": {
                "text": "Timeout-free Object.wait calls can block indefinitely"
              }
            },
            {
              "id": "OPTIONAL_GET_CALL",
              "name": "Optional direct getter call",
              "shortDescription": {
                "text": "Optional.get/getAs* can throw when empty"
              }
            },
            {
              "id": "PREFER_ENUMSET",
              "name": "Prefer EnumSet for enum collections",
              "shortDescription": {
                "text": "Using EnumSet for enum types provides better performance than general collections"
              }
            },
            {
              "id": "PRINT_STACK_TRACE",
              "name": "Direct printStackTrace call",
              "shortDescription": {
                "text": "Throwable.printStackTrace should be replaced with structured logging"
              }
            },
            {
              "id": "RECORD_ARRAY_FIELD",
              "name": "Record array field",
              "shortDescription": {
                "text": "Records should not use array-typed components"
              }
            },
            {
              "id": "RETURN_IN_FINALLY",
              "name": "Return in finally",
              "shortDescription": {
                "text": "Return statements in finally blocks override exceptions or prior returns"
              }
            },
            {
              "id": "RUNTIME_HALT_CALL",
              "name": "Runtime.halt call",
              "shortDescription": {
                "text": "Direct Runtime.halt(int) calls bypass graceful JVM shutdown"
              }
            },
            {
              "id": "RUN_FINALIZATION_CALL",
              "name": "Explicit finalization trigger call",
              "shortDescription": {
                "text": "System/Runtime runFinalization calls are unpredictable"
              }
            },
            {
              "id": "SLF4J_FORMAT_SHOULD_BE_CONST",
              "name": "SLF4J format should be const",
              "shortDescription": {
                "text": "SLF4J format strings should be compile-time constants"
              }
            },
            {
              "id": "SLF4J_ILLEGAL_PASSED_CLASS",
              "name": "SLF4J illegal passed class",
              "shortDescription": {
                "text": "LoggerFactory.getLogger should be called with the caller class"
              }
            },
            {
              "id": "SLF4J_LOGGER_SHOULD_BE_FINAL",
              "name": "SLF4J logger should be final",
              "shortDescription": {
                "text": "SLF4J Logger fields should be final"
              }
            },
            {
              "id": "SLF4J_LOGGER_SHOULD_BE_PRIVATE",
              "name": "SLF4J logger should be private",
              "shortDescription": {
                "text": "SLF4J Logger fields should be private"
              }
            },
            {
              "id": "SLF4J_MANUALLY_PROVIDED_MESSAGE",
              "name": "SLF4J preformatted message",
              "shortDescription": {
                "text": "SLF4J messages should use placeholders instead of manual formatting"
              }
            },
            {
              "id": "SLF4J_PLACEHOLDER_MISMATCH",
              "name": "SLF4J placeholder mismatch",
              "shortDescription": {
                "text": "SLF4J placeholder count does not match arguments"
              }
            },
            {
              "id": "SLF4J_SIGN_ONLY_FORMAT",
              "name": "SLF4J placeholder-only format",
              "shortDescription": {
                "text": "SLF4J format strings should include descriptive text"
              }
            },
            {
              "id": "SLF4J_UNKNOWN_ARRAY",
              "name": "SLF4J unknown array",
              "shortDescription": {
                "text": "SLF4J varargs calls with unknown argument arrays"
              }
            },
            {
              "id": "STRING_CASE_WITHOUT_LOCALE",
              "name": "String case conversion without explicit locale",
              "shortDescription": {
                "text": "String.toLowerCase()/toUpperCase() calls without Locale argument"
              }
            },
            {
              "id": "STRING_INTERN_CALL",
              "name": "String intern call",
              "shortDescription": {
                "text": "String.intern can increase global pool pressure and contention"
              }
            },
            {
              "id": "SYSTEM_EXIT",
              "name": "System.exit call",
              "shortDescription": {
                "text": "Direct calls to System.exit(int) terminate the JVM abruptly"
              }
            },
            {
              "id": "THREAD_RUN_DIRECT_CALL",
              "name": "Thread.run direct call",
              "shortDescription": {
                "text": "Direct Thread.run() calls execute synchronously on the current thread"
              }
            },
            {
              "id": "URL_EQUALS_CALL",
              "name": "URL equals call",
              "shortDescription": {
                "text": "URL.equals may trigger host resolution and surprising equality semantics"
              }
            },
            {
              "id": "URL_HASHCODE_CALL",
              "name": "URL hashCode call",
              "shortDescription": {
                "text": "URL.hashCode may trigger host resolution and surprising hash semantics"
              }
            }
          ],
          "semanticVersion": "0.0.0"
        }
      }
    }
  ],
  "version": "2.1.0"
}
