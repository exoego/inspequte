name: Rule Authoring (Codex)

on:
  workflow_dispatch:
    inputs:
      base_ref:
        description: "Optional base ref for verify-input diff (example: origin/main)"
        required: false
        default: ""
        type: string
      push_if_go:
        description: "Commit and push when verify recommendation is Go"
        required: false
        default: true
        type: boolean

env:
  BASE_REF: ${{ inputs.base_ref }}

# Design intent for 4 Codex phases:
# - phase1 (ideate+plan): establish one deterministic target and plan artifact.
# - phase2 (spec): lock the contract before implementation.
# - phase3 (impl): implement against fixed spec with test feedback.
# - phase4 (verify): evaluate only verify-input evidence and gate commit/push.
# Splitting phases reduces prompt/context mixing and makes each artifact auditable.
jobs:
  phase1_ideate_plan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      rule_id: ${{ steps.rule_meta.outputs.rule_id }}
      rule_idea: ${{ steps.rule_meta.outputs.rule_idea }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Prepare workspace
        run: |
          mkdir -p target/codex-workflow/prompts
          mkdir -p target/codex-workflow/output
          find src/rules -mindepth 2 -maxdepth 2 -name plan.md | LC_ALL=C sort > target/codex-workflow/baseline-plan-files.txt

      - name: Write phase-1 prompt (ideate + plan)
        run: |
          cat > target/codex-workflow/prompts/phase1-ideate-plan.md <<'PROMPT'
          You are Codex in this repository.

          Use both base prompts below:
          - `./prompts/ideate-rule.md`
          - `./prompts/authoring-plan.md`

          Phase scope:
          1. Ideate one rule (`rule-id`, `rule idea`) based on `./prompts/ideate-rule.md`.
          2. Create `src/rules/<RULE_ID>/plan.md` based on `./prompts/authoring-plan.md`.
          3. Do not create or modify `spec.md` in this phase.
          4. Do not implement or verify in this phase.

          Final response format (strict):
          rule-id: <snake_case_id>
          rule idea: <one short sentence>
          plan-path: src/rules/<snake_case_id>/plan.md
          PROMPT

      - name: Phase 1 - Ideate + Plan
        id: codex_phase1
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          safety-strategy: drop-sudo
          prompt-file: target/codex-workflow/prompts/phase1-ideate-plan.md
          output-file: target/codex-workflow/output/phase1-final-message.txt
          sandbox: workspace-write
          codex-args: --full-auto

      - name: Extract rule-id and rule idea
        id: rule_meta
        shell: bash
        run: |
          set -euo pipefail
          msg_file="target/codex-workflow/output/phase1-final-message.txt"

          rule_id="$(sed -nE 's/^[[:space:]]*rule-id:[[:space:]]*([a-z0-9_]+)[[:space:]]*$/\1/p' "${msg_file}" | head -n1)"
          rule_idea="$(sed -nE 's/^[[:space:]]*rule idea:[[:space:]]*(.+)[[:space:]]*$/\1/p' "${msg_file}" | head -n1)"

          if [[ -z "${rule_id}" ]]; then
            find src/rules -mindepth 2 -maxdepth 2 -name plan.md | LC_ALL=C sort > target/codex-workflow/after-phase1-plan-files.txt
            new_plan="$(comm -13 target/codex-workflow/baseline-plan-files.txt target/codex-workflow/after-phase1-plan-files.txt | head -n1 || true)"
            if [[ -n "${new_plan}" ]]; then
              rule_id="$(basename "$(dirname "${new_plan}")")"
            fi
          fi

          if [[ -z "${rule_id}" ]]; then
            echo "Failed to determine rule-id from phase-1 output." >&2
            exit 1
          fi

          if [[ -z "${rule_idea}" ]]; then
            rule_idea="Autogenerated rule idea for ${rule_id}"
          fi

          if [[ ! -f "src/rules/${rule_id}/plan.md" ]]; then
            echo "Expected plan file missing: src/rules/${rule_id}/plan.md" >&2
            exit 1
          fi

          {
            echo "rule_id=${rule_id}"
            echo "rule_idea<<EOF"
            echo "${rule_idea}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

          cat > target/codex-workflow/output/rule-meta.txt <<EOF
          rule-id: ${rule_id}
          rule idea: ${rule_idea}
          EOF

      - name: Capture cumulative patch (phase1)
        shell: bash
        run: |
          set -euo pipefail
          git add -A
          git diff --cached --binary > target/codex-workflow/output/phase1-cumulative.patch

      - name: Upload phase-1 artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: always()
        with:
          name: codex-phase1
          path: |
            target/codex-workflow/prompts/phase1-ideate-plan.md
            target/codex-workflow/output/phase1-final-message.txt
            target/codex-workflow/output/rule-meta.txt
            target/codex-workflow/output/phase1-cumulative.patch
            src/rules/${{ steps.rule_meta.outputs.rule_id }}/plan.md
          if-no-files-found: warn

  phase2_spec:
    runs-on: ubuntu-latest
    needs: phase1_ideate_plan
    permissions:
      contents: read
    outputs:
      rule_id: ${{ needs.phase1_ideate_plan.outputs.rule_id }}
      rule_idea: ${{ needs.phase1_ideate_plan.outputs.rule_idea }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Download phase-1 artifacts
        uses: actions/download-artifact@v5
        with:
          name: codex-phase1
          path: target/codex-workflow/from-phase1

      - name: Apply cumulative patch from phase1
        shell: bash
        run: |
          set -euo pipefail
          patch_file="target/codex-workflow/from-phase1/target/codex-workflow/output/phase1-cumulative.patch"
          if [[ ! -f "${patch_file}" ]]; then
            echo "Missing patch: ${patch_file}" >&2
            exit 1
          fi
          if [[ -s "${patch_file}" ]]; then
            git apply --whitespace=nowarn "${patch_file}"
          else
            echo "phase1 patch is empty; skipping apply."
          fi

      - name: Write phase-2 prompt (plan -> spec)
        env:
          RULE_ID: ${{ needs.phase1_ideate_plan.outputs.rule_id }}
          RULE_IDEA: ${{ needs.phase1_ideate_plan.outputs.rule_idea }}
        run: |
          mkdir -p target/codex-workflow/prompts target/codex-workflow/output
          cat > target/codex-workflow/prompts/phase2-spec.md <<EOF
          You are Codex in this repository.

          Use \`./prompts/authoring-spec.md\` as the base prompt and follow it strictly.

          Inputs:
          - rule-id: ${RULE_ID}
          - rule idea: ${RULE_IDEA}
          - plan path: src/rules/${RULE_ID}/plan.md

          Phase scope:
          1. Create or update only \`src/rules/${RULE_ID}/spec.md\`.
          2. Keep exact section order required by \`./prompts/authoring-spec.md\`.
          3. Do not implement, do not run verify, do not edit plan in this phase.

          Final response format (strict):
          rule-id: ${RULE_ID}
          spec-path: src/rules/${RULE_ID}/spec.md
          EOF

      - name: Phase 2 - Spec from Plan
        id: codex_phase2
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          safety-strategy: drop-sudo
          prompt-file: target/codex-workflow/prompts/phase2-spec.md
          output-file: target/codex-workflow/output/phase2-final-message.txt
          sandbox: workspace-write
          codex-args: --full-auto

      - name: Ensure spec exists
        run: |
          test -f "src/rules/${{ needs.phase1_ideate_plan.outputs.rule_id }}/spec.md"

      - name: Capture cumulative patch (phase2)
        shell: bash
        run: |
          set -euo pipefail
          git add -A
          git diff --cached --binary > target/codex-workflow/output/phase2-cumulative.patch

      - name: Upload phase-2 artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: always()
        with:
          name: codex-phase2
          path: |
            target/codex-workflow/prompts/phase2-spec.md
            target/codex-workflow/output/phase2-final-message.txt
            target/codex-workflow/output/phase2-cumulative.patch
            src/rules/${{ needs.phase1_ideate_plan.outputs.rule_id }}/plan.md
            src/rules/${{ needs.phase1_ideate_plan.outputs.rule_id }}/spec.md
          if-no-files-found: warn

  phase3_impl:
    runs-on: ubuntu-latest
    needs: phase2_spec
    permissions:
      contents: read
    outputs:
      rule_id: ${{ needs.phase2_spec.outputs.rule_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - uses: actions/setup-java@v5
        with:
          distribution: "temurin"
          java-version-file: ".java-version"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5 # v2

      - name: Download phase-2 artifacts
        uses: actions/download-artifact@v5
        with:
          name: codex-phase2
          path: target/codex-workflow/from-phase2

      - name: Apply cumulative patch from phase2
        shell: bash
        run: |
          set -euo pipefail
          patch_file="target/codex-workflow/from-phase2/target/codex-workflow/output/phase2-cumulative.patch"
          if [[ ! -f "${patch_file}" ]]; then
            echo "Missing patch: ${patch_file}" >&2
            exit 1
          fi
          if [[ -s "${patch_file}" ]]; then
            git apply --whitespace=nowarn "${patch_file}"
          else
            echo "phase2 patch is empty; skipping apply."
          fi

      - name: Write phase-3 prompt (spec -> impl)
        env:
          RULE_ID: ${{ needs.phase2_spec.outputs.rule_id }}
        run: |
          mkdir -p target/codex-workflow/prompts target/codex-workflow/output
          cat > target/codex-workflow/prompts/phase3-impl.md <<EOF
          You are Codex in this repository.

          Use \`./prompts/authoring-impl.md\` as the base prompt and follow it strictly.

          Inputs:
          - rule-id: ${RULE_ID}
          - spec path: src/rules/${RULE_ID}/spec.md

          Phase scope:
          1. Implement \`src/rules/${RULE_ID}/spec.md\` as contract.
          2. Add/adjust tests as needed.
          3. Run \`cargo fmt\` and \`cargo test\`.
          4. Do not run verify skill in this phase.

          Final response format (strict):
          rule-id: ${RULE_ID}
          impl-status: done
          EOF

      - name: Phase 3 - Implement from Spec
        id: codex_phase3
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          safety-strategy: drop-sudo
          prompt-file: target/codex-workflow/prompts/phase3-impl.md
          output-file: target/codex-workflow/output/phase3-final-message.txt
          sandbox: workspace-write
          codex-args: --full-auto

      - name: Phase 3 validation - cargo test
        shell: bash
        run: |
          set +e
          cargo test > target/codex-workflow/output/phase3-cargo-test.txt 2>&1
          phase3_test_exit=$?
          set -e
          echo "phase3 cargo test exit code: ${phase3_test_exit}"
          echo "${phase3_test_exit}" > target/codex-workflow/output/phase3-cargo-test.exitcode

      - name: Prepare verify-input and reports
        env:
          RULE_ID: ${{ needs.phase2_spec.outputs.rule_id }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p verify-input/reports
          if [[ -n "${BASE_REF}" ]]; then
            scripts/prepare-verify-input.sh "${RULE_ID}" "${BASE_REF}"
          else
            scripts/prepare-verify-input.sh "${RULE_ID}"
          fi

          set +e
          cargo build > verify-input/reports/cargo-build.txt 2>&1
          build_exit=$?

          cargo test > verify-input/reports/cargo-test.txt 2>&1
          test_exit=$?

          if ! command -v cargo-audit >/dev/null 2>&1; then
            cargo install cargo-audit --locked
          fi

          cargo audit --format sarif > verify-input/reports/cargo-audit.sarif
          audit_exit=$?
          if [[ ${audit_exit} -ne 0 ]]; then
            cat > verify-input/reports/cargo-audit.sarif <<'SARIF'
          {"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"cargo-audit"}},"results":[{"level":"error","message":{"text":"cargo audit failed in workflow"}}]}]}
          SARIF
          fi
          set -e

          cat > verify-input/reports/command-status.txt <<EOF
          cargo build exit code: ${build_exit}
          cargo test exit code: ${test_exit}
          cargo audit exit code: ${audit_exit}
          EOF

      - name: Capture cumulative patch (phase3)
        shell: bash
        run: |
          set -euo pipefail
          git add -A
          git diff --cached --binary > target/codex-workflow/output/phase3-cumulative.patch

      - name: Upload phase-3 artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: always()
        with:
          name: codex-phase3
          path: |
            target/codex-workflow/prompts/phase3-impl.md
            target/codex-workflow/output/phase3-final-message.txt
            target/codex-workflow/output/phase3-cargo-test.txt
            target/codex-workflow/output/phase3-cargo-test.exitcode
            target/codex-workflow/output/phase3-cumulative.patch
            src/rules/${{ needs.phase2_spec.outputs.rule_id }}/
            src/rules/mod.rs
            tests/snapshots/callgraph.sarif
            verify-input/
          if-no-files-found: warn

  phase4_verify:
    runs-on: ubuntu-latest
    needs: phase3_impl
    permissions:
      contents: read
    outputs:
      rule_id: ${{ needs.phase3_impl.outputs.rule_id }}
      recommendation: ${{ steps.verify_gate.outputs.recommendation }}
      adopt: ${{ steps.verify_gate.outputs.adopt }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Download phase-3 artifacts
        uses: actions/download-artifact@v5
        with:
          name: codex-phase3
          path: target/codex-workflow/from-phase3

      - name: Apply cumulative patch from phase3
        shell: bash
        run: |
          set -euo pipefail
          patch_file="target/codex-workflow/from-phase3/target/codex-workflow/output/phase3-cumulative.patch"
          if [[ ! -f "${patch_file}" ]]; then
            echo "Missing patch: ${patch_file}" >&2
            exit 1
          fi
          if [[ -s "${patch_file}" ]]; then
            git apply --whitespace=nowarn "${patch_file}"
          else
            echo "phase3 patch is empty; skipping apply."
          fi

      - name: Restore verify-input from phase3 artifacts
        shell: bash
        run: |
          set -euo pipefail
          rm -rf verify-input
          if [[ -d target/codex-workflow/from-phase3/verify-input ]]; then
            cp -R target/codex-workflow/from-phase3/verify-input ./verify-input
          else
            echo "verify-input not found in phase3 artifact; creating empty directory."
            mkdir -p verify-input/reports
          fi

      - name: Write phase-4 prompt (verify only)
        env:
          RULE_ID: ${{ needs.phase3_impl.outputs.rule_id }}
        run: |
          mkdir -p target/codex-workflow/prompts target/codex-workflow/output
          cat > target/codex-workflow/prompts/phase4-verify.md <<EOF
          You are Codex in this repository.

          Use \`./prompts/authoring-verify.md\` as the base prompt and follow it strictly.

          Inputs:
          - rule-id: ${RULE_ID}
          - verify directory: verify-input/

          Phase scope:
          1. Verify using only files under \`verify-input/\`.
          2. Write report to \`verify-input/verify-report.md\`.
          3. Do not modify implementation in this phase.

          Final response format (strict):
          recommendation: <Go|No-Go>
          report-path: verify-input/verify-report.md
          EOF

      - name: Phase 4 - Verify from Spec and verify-input
        id: codex_phase4
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          safety-strategy: drop-sudo
          prompt-file: target/codex-workflow/prompts/phase4-verify.md
          output-file: target/codex-workflow/output/phase4-final-message.txt
          sandbox: workspace-write
          codex-args: --full-auto

      - name: Evaluate verify recommendation
        id: verify_gate
        shell: bash
        run: |
          set -euo pipefail
          recommendation="No-Go"
          report_path="verify-input/verify-report.md"
          if [[ -f "${report_path}" ]]; then
            parsed="$(awk '/^## Recommendation \(Go\/No-Go\)/ {getline; gsub(/\r/, ""); print; exit}' "${report_path}" | xargs || true)"
            if [[ "${parsed}" == "Go" || "${parsed}" == "No-Go" ]]; then
              recommendation="${parsed}"
            fi
          fi

          adopt="false"
          if [[ "${recommendation}" == "Go" ]]; then
            adopt="true"
          fi

          {
            echo "recommendation=${recommendation}"
            echo "adopt=${adopt}"
          } >> "${GITHUB_OUTPUT}"

      - name: Capture cumulative patch (phase4)
        shell: bash
        run: |
          set -euo pipefail
          git add -A
          git diff --cached --binary > target/codex-workflow/output/phase4-cumulative.patch

      - name: Upload phase-4 artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        if: always()
        with:
          name: codex-phase4
          path: |
            target/codex-workflow/prompts/phase4-verify.md
            target/codex-workflow/output/phase4-final-message.txt
            target/codex-workflow/output/phase4-cumulative.patch
            verify-input/
          if-no-files-found: warn

      - name: Workflow summary
        if: always()
        run: |
          {
            echo "## Codex rule authoring workflow"
            echo ""
            echo "- rule-id: \`${{ needs.phase3_impl.outputs.rule_id || 'unknown' }}\`"
            echo "- recommendation: \`${{ steps.verify_gate.outputs.recommendation || 'unknown' }}\`"
          } >> "${GITHUB_STEP_SUMMARY}"

  commit_push:
    runs-on: ubuntu-latest
    needs: phase4_verify
    if: needs.phase4_verify.outputs.adopt == 'true' && inputs.push_if_go == true
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Download phase-4 artifacts
        uses: actions/download-artifact@v5
        with:
          name: codex-phase4
          path: target/codex-workflow/from-phase4

      - name: Apply cumulative patch from phase4
        shell: bash
        run: |
          set -euo pipefail
          patch_file="target/codex-workflow/from-phase4/target/codex-workflow/output/phase4-cumulative.patch"
          if [[ ! -f "${patch_file}" ]]; then
            echo "Missing patch: ${patch_file}" >&2
            exit 1
          fi
          if [[ -s "${patch_file}" ]]; then
            git apply --whitespace=nowarn "${patch_file}"
          else
            echo "phase4 patch is empty; skipping apply."
          fi

      - name: Create app token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: Commit and push
        env:
          RULE_ID: ${{ needs.phase4_verify.outputs.rule_id }}
          GH_APP_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          if [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes to commit."
            exit 0
          fi

          git add -A
          git commit -m "feat(rules): add ${RULE_ID} via codex workflow"
          git remote set-url origin "https://x-access-token:${GH_APP_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git push origin "HEAD:${GITHUB_REF_NAME}"
